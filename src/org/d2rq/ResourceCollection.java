package org.d2rq;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.d2rq.algebra.NodeRelation;
import org.d2rq.algebra.NodeRelationUtil;
import org.d2rq.algebra.TripleRelation;
import org.d2rq.db.SQLConnection;
import org.d2rq.db.op.LimitOp;
import org.d2rq.db.op.DatabaseOp;
import org.d2rq.db.op.util.OpUtil;
import org.d2rq.find.FindQuery;
import org.d2rq.find.TripleQueryIter;
import org.d2rq.nodes.FixedNodeMaker;
import org.d2rq.nodes.NodeMaker;
import org.d2rq.vocab.SKOS;

import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.sparql.core.Var;
import com.hp.hpl.jena.sparql.engine.ExecutionContext;
import com.hp.hpl.jena.sparql.vocabulary.FOAF;
import com.hp.hpl.jena.vocabulary.DC;
import com.hp.hpl.jena.vocabulary.DCTerms;
import com.hp.hpl.jena.vocabulary.RDF;
import com.hp.hpl.jena.vocabulary.RDFS;


/**
 * A collection of IRI-identified resources that are generated by a shared
 * rule (like a d2rq:ClassMap or rr:SubjectMap). The class provides access
 * to descriptions of the collection.
 * 
 * @author Richard Cyganiak (richard@cyganiak.de)
 */
public class ResourceCollection {
	private static final Log log = LogFactory.getLog(ResourceCollection.class);
	private static final Var RESOURCE = Var.alloc("resource");
	
	private final CompiledMapping mapping;
	private final SQLConnection sqlConnection;
	private final NodeMaker entityMaker;
	private final DatabaseOp entityTable;
	private final NodeRelation entityNodeRelation;
	private final Collection<TripleRelation> inventory;

	public ResourceCollection(CompiledMapping mapping, SQLConnection connection,
			NodeMaker entityMaker, 
			DatabaseOp entityTable, Collection<TripleRelation> entityDescription) {
		this.mapping = mapping;
		this.sqlConnection = connection;
		this.entityMaker = entityMaker;
		this.entityTable = entityTable;
		this.entityNodeRelation = new NodeRelation(connection,
				entityTable, Collections.singletonMap(RESOURCE, entityMaker));
		this.inventory = filterTripleRelations(entityDescription);
	}
	
	public Model getInventoryModel() {
		return getInventoryModel(LimitOp.NO_LIMIT);
	}

	public Model getInventoryModel(int limit) {
		log.info("Listing entity set: " + entityMaker);
		Model result = ModelFactory.createDefaultModel();
		result.setNsPrefixes(mapping.getPrefixes());
		FindQuery query = new FindQuery(Triple.ANY, inventory, limit, 
				new ExecutionContext(mapping.getContext(), null, null, null));
		result.getGraph().getBulkUpdateHandler().add(TripleQueryIter.create(query.iterator()));
		return result;
	}

	public boolean mayContain(Node node) {
		return !OpUtil.isEmpty(NodeRelationUtil.select(entityNodeRelation, RESOURCE, node).getBaseTabular());
	}

	private Collection<TripleRelation> filterTripleRelations(Collection<TripleRelation> entityDescription) {
		List<TripleRelation> result = new ArrayList<TripleRelation>();
		for (TripleRelation triples: entityDescription) {
			triples = triples.orderBy(TripleRelation.SUBJECT, true);
			if (triples.selectTriple(new Triple(Node.ANY, RDF.Nodes.type, Node.ANY)) != null) {
				result.add(triples);
			}
			// TODO: The list of label properties is redundantly specified in PageServlet
			if (triples.selectTriple(new Triple(Node.ANY, RDFS.label.asNode(), Node.ANY)) != null) {
				result.add(triples);
			} else if (triples.selectTriple(new Triple(Node.ANY, SKOS.prefLabel.asNode(), Node.ANY)) != null) {
				result.add(triples);
			} else if (triples.selectTriple(new Triple(Node.ANY, DC.title.asNode(), Node.ANY)) != null) {
				result.add(triples);					
			} else if (triples.selectTriple(new Triple(Node.ANY, DCTerms.title.asNode(), Node.ANY)) != null) {
				result.add(triples);					
			} else if (triples.selectTriple(new Triple(Node.ANY, FOAF.name.asNode(), Node.ANY)) != null) {
				result.add(triples);					
			}
		}
		if (result.isEmpty()) {
			result.add(new TripleRelation(sqlConnection, entityTable, 
					entityMaker, 
					new FixedNodeMaker(RDF.type.asNode()), 
					new FixedNodeMaker(RDFS.Resource.asNode())));
		}
		return result;
	}
}
